
수업기간: 2025-07-1 ~ 2025-07-25
수업시간: 아침 10 ~ 오후 2시 (하루 4시간)
수업진행: 50분수업(실습및 설명),  10분휴식
진행강사: 김영임

https://github.com/posasi2000/baewha2.git
https://www.dataq.or.kr

테이터베이스 개체 설명
1) Table : 행과열로 구성된 기본적인 테이타 저장개체
2) View :  테이블로부터 테이타의 부분집합을 논리적으로 표현한 개체
3) Sequence : 순차적인 숫자값을 생성하는 개체
4) index : 질의 성능을 향상하기 위해 사용하는 개체
5) Synonym : 개체이름에 대한 동의어(별명=닉네임)
6) Procedure : PL/SQL 프로시저
7) Function :  SQL사용자정의 함수  return키워드 있음 
8) trigger : 쿼리문을 자동실행  테이블이름 기술할때 ~~ on emp01


7월24일 목요일 수업내용 
 ㄴ1교시  데이터분석함수 , null함수응용, join
 ㄴ2교시  실행계획, 모델링 개념이해및 성능
 ㄴ3교시  모델링 개념이해및 성능
 ㄴ4교시  문제풀이 


윈도우시작아이콘 클릭후  cmd
윈도우시작아이콘 + R(run) 

C:\Users\여러분컴퓨터이름>  sqlplus system/1234
SQL> show user ;
     USER is "SYSTEM"  

set linesize 3400   -- 한 줄에 최대 3400자까지 출력
set pagesize 3400   -- 각 페이지마다 최대 3400행이 표시되도록 설정 

★ 객체대상 참고
 select  username from  dba_users ;
 select  username from  all_users ;
 select  table_name     from    user_tables ;
 select  sequence_name  from    user_sequences ; 
 select  constraint_name from    user_constraints ;
 select  view_name  from user_views ;  -- select결과 데이터 기억하는 객체 
 select  synonym_name, table_name  from user_synonyms ;  -- 시노님=동의어는 객체 이름에 대한 동의어  
 select  index_name  from user_indexes  where table_name = 'EMP3' ;
 select  trigger_name from user_triggers ;
 select  procedure_name from user_procedures ;


set linesize 3400  
set pagesize 3400  
col dname for a20
col ename for a10
col loc for a10
col hiredate for a10
col sal for 99999
col job for a10 ;



★ 1교시  데이터분석함수 , null함수응용, join
★ --------------------------------------------------------------------------------------
-- deptno부서별합계 그룹화
SQL> select job, sum(sal) as total from emp  group by job ;
	JOB             TOTAL
	---------- ----------
	CLERK            4150
	SALESMAN         5600
	PRESIDENT        5000
	MANAGER          8275
	ANALYST          6000


SQL> select  avg(sum(sal)) "total"  from emp  group by job ;
     total
     ----------
      5805


오라클에서 materialized view와 inline view는 모두 쿼리 성능 향상
 ㄴMaterialized view는 서브쿼리 결과를 디스크에 저장하고, 이후에 반복적으로 재사용할 수 있도록 하여 성능을 향상
 ㄴinline view는 쿼리 실행 시에만 임시적으로 사용되는 가상의 테이블역할, 메모리에만 유지되고, 쿼리가 실행될 때마다 다시 계산되므로 성능저하 

-- Materialization(머티리얼라이제이션)
-- CTE(common table expression)구문
-- 긴문장을 축약절 with  명명한이름   as ( )

SQL> with job_sumsal  as (select job, sum(sal) as total from emp group by job )
  select job, total from  job_sumsal
  where  total > ( select avg(total) from  job_sumsal) ;
	JOB             TOTAL
	---------- ----------
	MANAGER          8275
	ANALYST          6000


SQL> with job_sumsal as (select job, sum(sal) as total from emp group by job)
     select job, total  from job_sumsal
      where total > (select avg(total) from job_sumsal ) ;

	JOB             TOTAL
	--------------------
	MANAGER         8275
	ANALYST         6000



SQL> with job_sum AS (
     select job, sum(sal)  total
     from emp  group by job
   )
   select job, total from job_sum;

JOB                                           TOTAL
---------------------------------------- ----------
CLERK                                          4150
SALESMAN                                       5600
PRESIDENT                                      5000
MANAGER                                        8275
ANALYST                                        6000


-- with대신 서브쿼리의 인라인뷰inline view
select my.job,
       my.total
  from (
     select job, sum(sal) as total
     from emp  group by job
)my ;

JOB            SUM(SAL)
------------ ----------
CLERK              4150
SALESMAN           5600
PRESIDENT          5000
MANAGER            8275
ANALYST            6000




SQL> select job, sum(sal)   from emp  group by rollup(job) ;
	JOB          SUM(SAL)
	---------- ----------
	ANALYST          6000
	CLERK            4150
	MANAGER          8275
	PRESIDENT        5000
	SALESMAN         5600
                	29025


SQL> select job, sum(sal)  from emp  group by cube(job) ;
	JOB          SUM(SAL)
	---------- ----------
                	29025
	CLERK            4150
	ANALYST          6000
	MANAGER          8275
	SALESMAN         5600
	PRESIDENT        5000



col info for  a60 ;  -- 기술하면 좋아요
-- listagg  ~ within 가로출력  반드시 group by 기술필수
SQL> select deptno, listagg(ename, ',') 
     within group(order by ename) as info from emp 
     group by deptno ;

  DEPTNO  info
--------- ----------
  10 	  CLARK,KING,MILLER
  20 	  ADAMS,FORD,JONES,SCOTT,SMITH
  30 	  ALLEN,BLAKE,JAMES,MARTIN,TURNER,WARD



col job for a10 ;
col info for a50 ; 
SQL> select job, listagg(ename, ',') 
     within group(order by ename) as info from emp
     group by job ;

  job  		info
--------- ----------
ANALYST		FORD,SCOTT
CLERK		ADAMS,JAMES,MILLER,SMITH
MANAGER		BLAKE,CLARK,JONES
PRESIDENT	KING
SALESMAN	ALLEN,MARTIN,TURNER,WARD



col info for  a60 ;  -- 기술하면 좋아요
SQL> select job, listagg(ename || '(' ||sal||')', ',') 
     within group(order by ename)  info  from emp
     group by job ;

  job  		info
--------- ----------
ANALYST		FORD(3000),SCOTT(3000)
CLERK		ADAMS(1100),JAMES(950),MILLER(1300),SMITH(800)
MANAGER		BLAKE(2850),CLARK(2450),JONES(2975)
PRESIDENT	KING(5000)
SALESMAN	ALLEN(1600),MARTIN(1250),TURNER(1500),WARD(1250)



SQL> select empno, ename, job, sal
      from emp  where job in( 'ANALYST', 'MANAGER') ;
     EMPNO ENAME      JOB            SAL
---------- ---------- ------------ -----
      7566 JONES      MANAGER       2975
      7698 BLAKE      MANAGER       2850
      7782 CLARK      MANAGER       2450
      7788 SCOTT      ANALYST       3000
      7902 FORD       ANALYST       3000


-- lag전행, lead다음행 데이터 출력  이전,이후 데이터 표시 
SQL> select empno, ename, job, sal,
       lag(sal,1)  over(order by sal) "전 행" ,
       lead(sal,1) over(order by sal) "다음 행" 
     from emp  where job in( 'ANALYST', 'MANAGER') ;
     EMPNO ENAME      JOB            SAL      전 행    다음 행
---------- ---------- ------------ ----- ---------- ----------
      7782 CLARK      MANAGER       2450       null      2850
      7698 BLAKE      MANAGER       2850       2450       2975
      7566 JONES      MANAGER       2975       2850       3000
      7902 FORD       ANALYST       3000       2975       3000
      7788 SCOTT      ANALYST       3000       3000       null

SQL> select empno, ename, job, sal ,
    lag(sal, 1)  over(order by sal) "이전행" ,
    lead(sal, 1) over(order by sal) "다음행"
    from emp  ;




-- 복습 case ~ end,  decode()
실습] 조건처리 decode () 
   select code, grade,
   decode( grade , 'A', '10', 'B', '10', 'C', '5', 'D', '3', '1') as "결과" 
   from sosi ;

col  grade for a10 ;  -- char(1)라서 열제목공간을 늘려줌
실습] 조건처리 case ~ end 성적처리 축합격및 재시험을 아래 student에서 응용
 select code, grade ,
     case 
        when grade = 'A'   then  '합격'
        when grade = 'B'   then  '합격'
        when grade = 'C'   then  '보통'
        when grade = 'D'   then  '노력'
        else   '재수강'
      end   "결과"
   from sosi;



-- decode함수, sum함수 
 select sum(decode(deptno, 10, sal)) as "10" ,
        sum(decode(deptno, 20, sal)) as "20" ,
        sum(decode(deptno, 30, sal)) as "30" 
  from emp ;

        10         20         30
	---------- ---------- ----------
        8750      10875       9400


-- decode함수, pivot함수 ~ for 비교 결과는 같음
-- pivot=축 중심으로 회전한다 의미 
SQL> select * from (select deptno , sal from emp)
      pivot(sum(sal) for  deptno in(10,20,30)) ;

         10         20         30
	---------- ---------- ----------
         8750      10875       9400




-- 행번호 row_number() ~ over()만능함수
SQL> select row_number() over( order by deptno)  "num" ,
     deptno, empno, ename, job, sal from emp ;

       num     DEPTNO      EMPNO ENAME      JOB               SAL
---------- ---------- ---------- ---------- ---------- ----------
         1         10       7782 CLARK      MANAGER          2450
         2         10       7839 KING       PRESIDENT        5000
         3         10       7934 MILLER     CLERK            1300
         4         20       7566 JONES      MANAGER          2975
         5         20       7902 FORD       ANALYST          3000
         6         20       7876 ADAMS      CLERK            1100
         7         20       7369 SMITH      CLERK             800
         8         20       7788 SCOTT      ANALYST          3000
         9         30       7521 WARD       SALESMAN         1250
        10         30       7844 TURNER     SALESMAN         1500
        11         30       7499 ALLEN      SALESMAN         1600
        12         30       7900 JAMES      CLERK             950
        13         30       7698 BLAKE      MANAGER          2850
        14         30       7654 MARTIN     SALESMAN         1250



★ 쉬어가는 코너 coalesce, nvl 복습   
★ --------------------------------------------------------------------------------------
  select  coalesce(null, '234', '10') from dual ;
  select empno,ename, sal, comm,  sal+comm  "합계" from  emp ; -- 단점
  select empno,ename, sal, nvl(comm,0) from  emp ;
  select empno,ename, sal, coalesce(comm,0) from  emp ;


drop  table  tab1 ;
create table  tab1( col1  integer,  col2  integer,  col3  integer ) ;

insert into tab1 values( 10, 20, null);
insert into tab1 values( 15, null, null);
insert into tab1 values( 60, 70, 50);
select * from tab1;
commit ;

col1    col2    col3
-----------------------
 10      20     null    ===>이순신
 15     null    null    ===>홍길동
 60      70      50     ===>김디비


SQL> select sum(col1+col2+col3) from tab1 ;
	SUM(COL1+COL2+COL3)
	-------------------
                180

 select coalesce(col1,col2,col3)   from tab1;   -- 10 15 60 출력
	COALESCE(COL1,COL2,COL3)
	------------------------
                      10
                      15
                      60

 select sum(coalesce(col1,col2,col3))   from tab1;
	COALESCE(COL1,COL2,COL3)
	------------------------
                     85

-- nullif(표현식1, 표현식2) 만족하면 null, 불만족하면 표현식1갖음
SQL> select ename, empno, mgr, nullif(mgr,7698) "nullif"  from emp ;

ENAME           EMPNO        MGR     nullif
---------- ---------- ---------- ----------
SMITH            7369       7902       7902
ALLEN            7499       7698
WARD             7521       7698
JONES            7566       7839       7839
MARTIN           7654       7698
BLAKE            7698       7839       7839
CLARK            7782       7839       7839
SCOTT            7788       7566       7566
KING             7839
TURNER           7844       7698
ADAMS            7876       7788       7788
JAMES            7900       7698
FORD             7902       7566       7566
MILLER           7934       7782       7782

SQL> select ename, empno, sal, comm, coalesce(comm,sal) "coalesce"  from emp ;

ENAME                     EMPNO        SAL       COMM   coalesce
-------------------- ---------- ---------- ---------- ----------
SMITH                      7369        800                   800
ALLEN                      7499       1600        300        300
WARD                       7521       1250        200        200
JONES                      7566       2975         30         30
MARTIN                     7654       1250        300        300
BLAKE                      7698       2850                  2850
CLARK                      7782       2450                  2450
SCOTT                      7788       3000                  3000
KING                       7839       5000       3500       3500
TURNER                     7844       1500          0          0
ADAMS                      7876       1100                  1100
JAMES                      7900        950                   950
FORD                       7902       3000                  3000
MILLER                     7934       1300                  1300
14 rows selected.


SQL> select ename, sal  from emp
     order by sal desc
     fetch first 2 rows with ties ; 
       오라클 12c에서 인식 ERROR at line 3:
       오라클 12c에서 인식 ORA-00933: SQL command not properly ended

SQL> select top(2) with ties  ename, sal from emp order by sal  ;
	MS사 ms-sql서버 ERROR at line 1:
	MS사 ms-sql서버 ORA-00923: FROM keyword not found where expected


SQL> select ename, sal from (
      select ename, sal, rank() over (order by sal desc) as rnk
       from emp
    ) where rnk <= 2 ;

ENAME        SAL
---------- -----
KING        5000
SCOTT       3000
FORD        3000







★ baewha유저 이미 생성했으니 참조만 하세요 
SQL> create user baewha
     identified by 1234
     default tablespace users
     temporary tablespace temp ;


user유저확인 명령어
SQL> select  username from  dba_users ;
SQL> select  username from  all_users ;

baewha유저 접속및 자원 권한부여
SQL> grant  connect  to baewha ;
SQL> grant  resource to  baewha ;
SQL> grant  dba  to  baewha ;



SQL>  connect baewhe/1234 ;
SQL> show user ;
SQL> desc guest ;
SQL> desc guestreply ;
SQL> select * from guest ;
      CODE NAME                 TITLE                            WDATE           HIT
---------- -------------------- -------------------------------- -------- ----------
      5500 aa                   note                             25/07/17          0
      9900 cc                   cake                             25/07/17          0
      7700 bb                   blue                             25/07/18         65

SQL> select * from guestreply ;
       NUM WRITER               CONTENT                                        CODE
---------- -------------------- ---------------------------------------- ----------
         1 rain                 rain                                           7700
         2 lee                  lee                                            5500
         3 snow                 snow                                           7700
         4 last                 last                                           7700
 
--  FK에러
insert into guestreply values(guestreply_seq.nextval, 'young', 'young', 2200);
    ERROR at line 1:
    ORA-02291: integrity constraint (SYSTEM.FK_GUESTREPLY_GUEST) violated - parent key not found

-- PK에러이유는 unique같은종류
insert into guest values(5500, 'LG', 'LG', sysdate, 7);
   ERROR at line 1:
   ORA-00001: unique constraint (SYSTEM.SYS_C008727) violated


-- 서브쿼리는 NL = Nested Loops (중첩 반복)
-- join는 여러테이블 연결해서 원하는 데이터 추출목적
카티시안 곱(Cartesian Product)은 조인조건없이 cross join 또는 from절에 두 테이블을 나란히 기술하면 됩니다 
두 테이블의 모든 조합을 반환합니다.
실제 업무에서 의도된 경우가 아니면 잘 사용하지 않으며, 실수로 수행할 경우 성능 저하가 발생할 수 있습니다.
-- emp 테이블에 14행, dept 테이블에 4행이 있다면 → 14 × 4 = 56행 반환됩니다.
SQL> select  *  from emp  cross join dept ;   -- 56row 반환
SQL> select  *  from emp, dept ;  -- 56row 반환

-- using절 , MSSQL server는 지원하지 않습니다 
SQL> select * from emp inner join  dept using(deptno) ;

-- natual join조인  공통필드 deptno출력하면에러발생  using절생략함 
SQL> select empno, ename, job,  sal,  dname, loc
     from  emp  e  natural join  dept d ;

-- non-equi이퀴조인 
SQL> select e.empno,  e.ename, e.job,  e.sal, s.grade || '등급'   "grade"
  from emp e, salgrade  s
  where e.sal between  s.losal  and  s.hisal ; 


-- self join 같은테이블에서 조인 
-- mgr필드, empno필드  비교
SQL> select  e.empno , e.ename , m.empno , m.ename  
 from  emp  e,   emp  m
 where  e.mgr = m.empno  order by  m.ename ;

-- full  full outer join 조인은 데이타 참조없는 부서코드까지 다 출력 
SQL> select  e.empno, e.ename, d.deptno,  d.dname, d.loc
 from  emp e  full outer join    dept  d
 on  e.deptno = d.deptno ; 

SQL> select  e.empno, e.ename, d.deptno,  d.dname, d.loc
from emp e,  dept  d
where  e.deptno(+) = d.deptno ;


SQL> select  e.empno, e.ename, d.deptno,  d.dname, d.loc
from emp e   right  outer  join   dept  d
on  e.deptno = d.deptno ; 





★ 2교시 실행계획, 모델링 개념이해및 성능
★ --------------------------------------------------------------------------------------
SQL> select * from  emp ;
      14 rows selected.데이터출력

SQL> set autotrace on  ;  -- 쿼리 결과 + 실행계획 + 통계(물리적 읽기 등)를 함께 보여줍니다.
실습금지SQL> set autotrace traceonly ;  --   결과 없이 계획만 출력됩니다.


-- natual join조인  공통필드 deptno출력하면에러발생  using절생략함 
SQL> select empno, ename, job,  sal,  dname, loc
     from  emp  e  natural join  dept d ;


SQL> select  e.empno, e.ename, d.deptno,  d.dname, d.loc
  from emp e,  dept  d
  where  e.deptno(+) = d.deptno ;


SQL> select  e.empno, e.ename, d.deptno,  d.dname, d.loc
  from emp e   right  outer  join   dept  d
  on  e.deptno = d.deptno ; 



-- 참고 살짝다르게 출력되지만  결론은 실행계획을 분석 진단
explain plan for 
select * from  emp;
select * from table( dbms_xplan.display);


SQL> set autotrace on  ;  -- 쿼리 결과 + 실행계획 + 통계(물리적 읽기 등)를 함께 보여줍니다.




★ 3교시 모델링 개념이해및 성능 
★ --------------------------------------------------------------------------------------
IE 표기법 = information Engineering Notation
IE표기법은 관계를 나타내는 선의 끝 모양이 새의 발 모양처럼 생겼다해서 새발 표기법crow-feet이라고도 부른다고 한다.

Barker표기법


★ 4교시 문제풀이
★ --------------------------------------------------------------------------------------




★ --------------------------------------------------------------------------------------
★ 서비스 확인하면 좋습니다
윈도우10 제어판-> 관리도구->  서비스 
 ㄴOracleServiceXE 시작됨 자동(오라클DB설치하면 자동실행됨)
 ㄴOracleXETNSListener 시작됨 자동(오라클DB설치하면 자동실행됨)

윈도우11 작업관리자 -> 서비스 
 ㄴOracleServiceXE 실행중(오라클DB설치하면 자동실행됨)
 ㄴOracleXETNSListener 실행중(오라클DB설치하면 자동실행됨)

★ --------------------------------------------------------------------------------------
참고 웹프로그램 할때는 포트번호를 변경하면 좋아요
SQL> select dbms_xdb.gethttpport() from dual
SQL> exec dbms_xdb.sethttpport(8888)
SQL> select dbms_xdb.gethttpport() from dual


jdk먼저설치, sqldeveloper설치
//추천  SQL Developer 다운로드 
//크롬웹브라우저 Oracel SQL Developer 19.2.1(64-1)
https://www.filehorse.com/download-oracle-sql-developer-64/43305/download/


//비추천 SQL Developer 다운로드 24.3.1 최신버젼 버젼
//SQL Developer 24.3.1 
 https://www.oracle.com/tools/downloads/sqldev-downloads.html
 https://www.oracle.com/database/sqldeveloper/technologies/download/




















